<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SC2API: Tutorial 3: Building Marines and Scouting</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="SC2-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SC2API
   </div>
   <div id="projectbrief">An API for AI for StarCraft II</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 3: Building Marines and Scouting </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>So far we've been focused on some of the simpler macro abilities required to make a bot. You've gotten your bot to build scv's and supply depots when it's running near the supply cap. In this tutorial we'll learn the following.</p>
<ol type="1">
<li>Building a Barracks.</li>
<li>Building Marines from said Barracks.</li>
<li>Scouting Your Opponent.</li>
</ol>
<p>This tutorial builds on the previous so make sure the code from the last tutorial is copy pasted into tutorial.cc and you can build/run it.</p>
<h2>Building a Barracks </h2>
<p>The first step to any good Terran build is to build marines, and to build marines we must first build a barracks. We've already seen how to construct supply depots so lets create some similar code for constructing a barracks. Modify your OnStep function to the following.</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">virtual void OnStep() final {</div><div class="line">    TryBuildSupplyDepot();</div><div class="line"></div><div class="line">    TryBuildBarracks();</div><div class="line">}</div></div><!-- fragment --><blockquote class="doxtable">
<p>We'll implement TryBuildBarracks shortly. </p>
</blockquote>
<p>First, we have some constraints we must satisfy to build a barracks, primarily, we need a supply depot. We'd also like to only build one for this this tutorial so lets create a helper function for counting unit types and we'll use that in TryBuildBarracks in order to determine if we should build one or not.</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">size_t CountUnitType(UNIT_TYPEID unit_type) {</div><div class="line">    return Observation()-&gt;GetUnits(Unit::Alliance::Self, IsUnit(unit_type)).size();</div><div class="line">}</div></div><!-- fragment --><p>That function is counting the number of a certain unit type the player owns. GetUnits takes a Filter parameter that allows you to remove units that don't meet a certain condition. In this case that condition is that the units are of the desired unit_type.</p>
<p>We now have the necessary helper functions to implement TryBuildBarracks.</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">bool TryBuildBarracks() {</div><div class="line">    const ObservationInterface* observation = Observation();</div><div class="line"></div><div class="line">    if (CountUnitType(UNIT_TYPEID::TERRAN_SUPPLYDEPOT) &lt; 1) {</div><div class="line">        return false;</div><div class="line">    }</div><div class="line"></div><div class="line">    if (CountUnitType(UNIT_TYPEID::TERRAN_BARRACKS) &gt; 0) {</div><div class="line">        return false;</div><div class="line">    }</div><div class="line"></div><div class="line">    return TryBuildStructure(ABILITY_ID::BUILD_BARRACKS);</div><div class="line">}</div></div><!-- fragment --><p>You can build and run your code at this point, if you'd like, you should see your bot building a barracks after it completes its first supply depot. We'd now like that barracks to actually do something. Recall we've overwritten a OnUnitIdle event in an earlier tutorial, completion of the barracks should trigger that event!</p>
<h2>Building Marines </h2>
<p>Similar to how we construct SCVs we can now produce marines. Add the following code to the switch case in OnUnitIdle. The entire function should look like the following, the new code is the UNIT_TYPE::TERRAN_BARRACKS case:</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">virtual void OnUnitIdle(const Unit* unit) final {</div><div class="line">    switch (unit-&gt;unit_type.ToType()) {</div><div class="line">        case UNIT_TYPEID::TERRAN_COMMANDCENTER: {</div><div class="line">            Actions()-&gt;UnitCommand(unit, ABILITY_ID::TRAIN_SCV);</div><div class="line">            break;</div><div class="line">        }</div><div class="line">        case UNIT_TYPEID::TERRAN_SCV: {</div><div class="line">            const Unit* mineral_target = FindNearestMineralPatch(unit-&gt;pos);</div><div class="line">            if (!mineral_target) {</div><div class="line">                break;</div><div class="line">            }</div><div class="line">            Actions()-&gt;UnitCommand(unit, ABILITY_ID::SMART, mineral_target);</div><div class="line">            break;</div><div class="line">        }</div><div class="line">        case UNIT_TYPEID::TERRAN_BARRACKS: {</div><div class="line">            Actions()-&gt;UnitCommand(unit, ABILITY_ID::TRAIN_MARINE);</div><div class="line">            break;</div><div class="line">        }</div><div class="line">        case UNIT_TYPEID::TERRAN_MARINE: {</div><div class="line">            const GameInfo&amp; game_info = Observation()-&gt;GetGameInfo();</div><div class="line">            Actions()-&gt;UnitCommand(unit, ABILITY_ID::ATTACK_ATTACK, game_info.enemy_start_locations.front());</div><div class="line">            break;</div><div class="line">        }</div><div class="line">        default: {</div><div class="line">            break;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Notice how easy that is! In general, OnUnitIdle is an excellent function to add code to to control unit production and orders. At this point if you build and run the code your bot should build a barracks and start producing marines with them. Our last step should be to scout the enemy.</p>
<h2>Scouting Your Opponent </h2>
<p>In a normal match when the game begins the minimap is pinged with all possible starting locations of enemies, the api contains that same information in the ObservationInterface. You can retrieve it via GetGameInfo(). Lets use that function in our OnUnitIdle so a newly spawned marine will attack move towards the enemy as soon as it's spawned. It will be fun to see countless marines walk to their demise.</p>
<p>In your OnUnitIdle add the following code to your switch case -</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">case UNIT_TYPEID::TERRAN_MARINE: {</div><div class="line">    const GameInfo&amp; game_info = Observation()-&gt;GetGameInfo();</div><div class="line">    Actions()-&gt;UnitCommand(unit, ABILITY_ID::ATTACK_ATTACK, game_info.enemy_start_locations.front());</div><div class="line">    break;</div><div class="line">}</div></div><!-- fragment --><p>How fun, build and run and you can watch marines endlessly walk to their death.</p>
<h2>Exercises </h2>
<ol type="1">
<li>Try building and producing marines from three barracks instead of one.</li>
<li>(Challenging) Perform a simple rush, from your three barracks wait until you've gathered 10-20 marines then attack move to your enemy.</li>
</ol>
<h2>Full Source Code </h2>
<div class="fragment"><div class="line">{C++}</div><div class="line">#include &lt;sc2api/sc2_api.h&gt;</div><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace sc2;</div><div class="line"></div><div class="line">class Bot : public Agent {</div><div class="line">public:</div><div class="line">    virtual void OnGameStart() final {</div><div class="line">        std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    virtual void OnStep() final {</div><div class="line">        TryBuildSupplyDepot();</div><div class="line"></div><div class="line">        TryBuildBarracks();</div><div class="line">    }</div><div class="line"></div><div class="line">    virtual void OnUnitIdle(const Unit* unit) final {</div><div class="line">        switch (unit-&gt;unit_type.ToType()) {</div><div class="line">            case UNIT_TYPEID::TERRAN_COMMANDCENTER: {</div><div class="line">                Actions()-&gt;UnitCommand(unit, ABILITY_ID::TRAIN_SCV);</div><div class="line">                break;</div><div class="line">            }</div><div class="line">            case UNIT_TYPEID::TERRAN_SCV: {</div><div class="line">                const Unit* mineral_target = FindNearestMineralPatch(unit-&gt;pos);</div><div class="line">                if (!mineral_target) {</div><div class="line">                    break;</div><div class="line">                }</div><div class="line">                Actions()-&gt;UnitCommand(unit, ABILITY_ID::SMART, mineral_target);</div><div class="line">                break;</div><div class="line">            }</div><div class="line">            case UNIT_TYPEID::TERRAN_BARRACKS: {</div><div class="line">                Actions()-&gt;UnitCommand(unit, ABILITY_ID::TRAIN_MARINE);</div><div class="line">                break;</div><div class="line">            }</div><div class="line">            case UNIT_TYPEID::TERRAN_MARINE: {</div><div class="line">                const GameInfo&amp; game_info = Observation()-&gt;GetGameInfo();</div><div class="line">                Actions()-&gt;UnitCommand(unit, ABILITY_ID::ATTACK_ATTACK, game_info.enemy_start_locations.front());</div><div class="line">                break;</div><div class="line">            }</div><div class="line">            default: {</div><div class="line">                break;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">private:</div><div class="line">    size_t CountUnitType(UNIT_TYPEID unit_type) {</div><div class="line">        return Observation()-&gt;GetUnits(Unit::Alliance::Self, IsUnit(unit_type)).size();</div><div class="line">    }</div><div class="line"></div><div class="line">    bool TryBuildStructure(ABILITY_ID ability_type_for_structure, UNIT_TYPEID unit_type = UNIT_TYPEID::TERRAN_SCV) {</div><div class="line">        const ObservationInterface* observation = Observation();</div><div class="line"></div><div class="line">        // If a unit already is building a supply structure of this type, do nothing.</div><div class="line">        // Also get an scv to build the structure.</div><div class="line">        const Unit* unit_to_build = nullptr;</div><div class="line">        Units units = observation-&gt;GetUnits(Unit::Alliance::Self);</div><div class="line">        for (const auto&amp; unit : units) {</div><div class="line">            for (const auto&amp; order : unit-&gt;orders) {</div><div class="line">                if (order.ability_id == ability_type_for_structure) {</div><div class="line">                    return false;</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">            if (unit-&gt;unit_type == unit_type) {</div><div class="line">                unit_to_build = unit;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        float rx = GetRandomScalar();</div><div class="line">        float ry = GetRandomScalar();</div><div class="line"></div><div class="line">        Actions()-&gt;UnitCommand(unit_to_build,</div><div class="line">            ability_type_for_structure,</div><div class="line">            Point2D(unit_to_build-&gt;pos.x + rx * 15.0f, unit_to_build-&gt;pos.y + ry * 15.0f));</div><div class="line"></div><div class="line">        return true;</div><div class="line">    }</div><div class="line"></div><div class="line">    bool TryBuildSupplyDepot() {</div><div class="line">        const ObservationInterface* observation = Observation();</div><div class="line"></div><div class="line">        // If we are not supply capped, don&#39;t build a supply depot.</div><div class="line">        if (observation-&gt;GetFoodUsed() &lt;= observation-&gt;GetFoodCap() - 2)</div><div class="line">            return false;</div><div class="line"></div><div class="line">        // Try and build a depot. Find a random SCV and give it the order.</div><div class="line">        return TryBuildStructure(ABILITY_ID::BUILD_SUPPLYDEPOT);</div><div class="line">    }</div><div class="line"></div><div class="line">    const Unit* FindNearestMineralPatch(const Point2D&amp; start) {</div><div class="line">        Units units = Observation()-&gt;GetUnits(Unit::Alliance::Neutral);</div><div class="line">        float distance = std::numeric_limits&lt;float&gt;::max();</div><div class="line">        const Unit* target = nullptr;</div><div class="line">        for (const auto&amp; u : units) {</div><div class="line">            if (u-&gt;unit_type == UNIT_TYPEID::NEUTRAL_MINERALFIELD) {</div><div class="line">                float d = DistanceSquared2D(u-&gt;pos, start);</div><div class="line">                if (d &lt; distance) {</div><div class="line">                    distance = d;</div><div class="line">                    target = u;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        return target;</div><div class="line">    }</div><div class="line"></div><div class="line">    bool TryBuildBarracks() {</div><div class="line">        const ObservationInterface* observation = Observation();</div><div class="line"></div><div class="line">        if (CountUnitType(UNIT_TYPEID::TERRAN_SUPPLYDEPOT) &lt; 1) {</div><div class="line">            return false;</div><div class="line">        }</div><div class="line"></div><div class="line">        if (CountUnitType(UNIT_TYPEID::TERRAN_BARRACKS) &gt; 0) {</div><div class="line">            return false;</div><div class="line">        }</div><div class="line"></div><div class="line">        return TryBuildStructure(ABILITY_ID::BUILD_BARRACKS);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">int main(int argc, char* argv[]) {</div><div class="line">    Coordinator coordinator;</div><div class="line">    coordinator.LoadSettings(argc, argv);</div><div class="line"></div><div class="line">    Bot bot;</div><div class="line">    coordinator.SetParticipants({</div><div class="line">        CreateParticipant(Race::Terran, &amp;bot),</div><div class="line">        CreateComputer(Race::Zerg)</div><div class="line">    });</div><div class="line"></div><div class="line">    coordinator.LaunchStarcraft();</div><div class="line">    coordinator.StartGame(sc2::kMapBelShirVestigeLE);</div><div class="line"></div><div class="line">    while (coordinator.Update()) {</div><div class="line">    }</div><div class="line"></div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
