<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SC2API: Tutorial 2: SCVs and Supply Depots</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="SC2-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SC2API
   </div>
   <div id="projectbrief">An API for AI for StarCraft II</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 2: SCVs and Supply Depots </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The goal in this tutorial will be to build scvs and supply depots.</p>
<ol type="1">
<li>Building SCVs.</li>
<li>Building Supply Depots.</li>
<li>Managing idle SCVs.</li>
</ol>
<p>As a starting point you should have the code from the end of tutorial 1 compiling and running. This tutorial will start where the last one left off.</p>
<h2>Building SCVs </h2>
<p>The library provides many events for your convenience, a big one we will use for this tutorial is the OnUnitIdle event. This function will get called each time a unit has been built and has no orders or the unit had orders in the previous step and currently does not.</p>
<blockquote class="doxtable">
<p>In both the Starcraft 2 engine and library both buildings and units are considered units and are represented with a Unit object. </p>
</blockquote>
<p>Add the following code to your Bot class.</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">// In your bot class.</div><div class="line">virtual void OnUnitIdle(const Unit* unit) final {</div><div class="line">    switch (unit-&gt;unit_type.ToType()) {</div><div class="line">        case UNIT_TYPEID::TERRAN_COMMANDCENTER: {</div><div class="line">            Actions()-&gt;UnitCommand(unit, ABILITY_ID::TRAIN_SCV);</div><div class="line">            break;</div><div class="line">        }</div><div class="line">        default: {</div><div class="line">            break;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>As you can see we are going to try to build an SCV with the idle unit if it is a Command Center.</p>
<blockquote class="doxtable">
<p>The UNIT_TYPEID enum holds the ids of common units you are likely to find in 1v1 matches. Feel free to look at <a class="el" href="sc2__typeenums_8h.html" title="A list of enums provided for your convenience. ">sc2_typeenums.h</a> to see a list of units and their corresponding id. </p>
</blockquote>
<h2>Building Supply Depots </h2>
<p>Compile and run your bot now. You will see the Command Center making scvs up until the supply cap. That seems pretty good! We just need to build some supply depots now, lets replace the code in OnStep with the following.</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">virtual void OnStep() {</div><div class="line">    TryBuildSupplyDepot();</div><div class="line">}</div></div><!-- fragment --><p>Implement TryBuildSupplyDepot and TryBuildStructure as functions of our bot class.</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">bool TryBuildStructure(ABILITY_ID ability_type_for_structure, UNIT_TYPEID unit_type = UNIT_TYPEID::TERRAN_SCV) {</div><div class="line">    const ObservationInterface* observation = Observation();</div><div class="line"></div><div class="line">    // If a unit already is building a supply structure of this type, do nothing.</div><div class="line">    // Also get an scv to build the structure.</div><div class="line">    const Unit* unit_to_build = nullptr;</div><div class="line">    Units units = observation-&gt;GetUnits(Unit::Alliance::Self);</div><div class="line">    for (const auto&amp; unit : units) {</div><div class="line">        for (const auto&amp; order : unit-&gt;orders) {</div><div class="line">            if (order.ability_id == ability_type_for_structure) {</div><div class="line">                return false;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        if (unit-&gt;unit_type == unit_type) {</div><div class="line">           unit_to_build = unit;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    float rx = GetRandomScalar();</div><div class="line">    float ry = GetRandomScalar();</div><div class="line"></div><div class="line">    Actions()-&gt;UnitCommand(unit_to_build,</div><div class="line">        ability_type_for_structure,</div><div class="line">        Point2D(unit_to_build-&gt;pos.x + rx * 15.0f, unit_to_build-&gt;pos.y + ry * 15.0f));</div><div class="line"></div><div class="line">    return true;</div><div class="line">}</div><div class="line"></div><div class="line">bool TryBuildSupplyDepot() {</div><div class="line">    const ObservationInterface* observation = Observation();</div><div class="line"></div><div class="line">    // If we are not supply capped, don&#39;t build a supply depot.</div><div class="line">    if (observation-&gt;GetFoodUsed() &lt;= observation-&gt;GetFoodCap() - 2)</div><div class="line">        return false;</div><div class="line"></div><div class="line">    // Try and build a depot. Find a random SCV and give it the order.</div><div class="line">    return TryBuildStructure(ABILITY_ID::BUILD_SUPPLYDEPOT);</div><div class="line">}</div></div><!-- fragment --><p>Compile and run your bot now. It's mining and building supply depots, it's almost ready for ladder! You'll notice when the SCV is done building a supply depot it sits idle, how useless. Lets fix that now.</p>
<h2>Managing Idle SCVs </h2>
<p>We have already hooked into the on idle event for building SCVs, we can use that same function to manage idle ones. Refactor your OnUnitIdle function with the following.</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">virtual void OnUnitIdle(const Unit* unit) final {</div><div class="line">    switch (unit-&gt;unit_type.ToType()) {</div><div class="line">        case UNIT_TYPEID::TERRAN_COMMANDCENTER: {</div><div class="line">            Actions()-&gt;UnitCommand(unit, ABILITY_ID::TRAIN_SCV);</div><div class="line">            break;</div><div class="line">        }</div><div class="line">        case UNIT_TYPEID::TERRAN_SCV: {</div><div class="line">            const Unit* mineral_target = FindNearestMineralPatch(unit-&gt;pos);</div><div class="line">            if (!mineral_target) {</div><div class="line">                break;</div><div class="line">            }</div><div class="line">            Actions()-&gt;UnitCommand(unit, ABILITY_ID::SMART, mineral_target);</div><div class="line">            break;</div><div class="line">        }</div><div class="line">        default: {</div><div class="line">            break;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><blockquote class="doxtable">
<p>The ability type of SMART is equivalent to a right click in Starcraft 2 when you have a unit selected. </p>
</blockquote>
<p>Now we just need to implement FindNearestMineralPatch and we can fix our lazy SCV.</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">const Unit* FindNearestMineralPatch(const Point2D&amp; start) {</div><div class="line">    Units units = Observation()-&gt;GetUnits(Unit::Alliance::Neutral);</div><div class="line">    float distance = std::numeric_limits&lt;float&gt;::max();</div><div class="line">    const Unit* target = nullptr;</div><div class="line">    for (const auto&amp; u : units) {</div><div class="line">        if (u-&gt;unit_type == UNIT_TYPEID::NEUTRAL_MINERALFIELD) {</div><div class="line">            float d = DistanceSquared2D(u-&gt;pos, start);</div><div class="line">            if (d &lt; distance) {</div><div class="line">                distance = d;</div><div class="line">                target = u;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    return target;</div><div class="line">}</div></div><!-- fragment --><h2>Exercises </h2>
<blockquote class="doxtable">
<p>These exercises are very optional, so feel free to move onto the next tutorial. Otherwise, they act as a fun way to discover more about the API. </p>
</blockquote>
<ol type="1">
<li>As you build more scvs you'll want to start building supply depots at a higher rate. Try modifying the code to build multiple supply depots instead of just 1 at a time.</li>
<li>(Challenging) Build two refineries and start mining gas. You can use code similar to FindNearestMineralPatch to find a geyser. You'll then want to detect when the refinery is either created or becomes idle and begin gathering gas with 3 scvs.</li>
</ol>
<h2>Full Source Code </h2>
<div class="fragment"><div class="line">{C++}</div><div class="line">#include &lt;sc2api/sc2_api.h&gt;</div><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace sc2;</div><div class="line"></div><div class="line">class Bot : public Agent {</div><div class="line">public:</div><div class="line">    virtual void OnGameStart() final {</div><div class="line">        std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    virtual void OnStep() final {</div><div class="line">        TryBuildSupplyDepot();</div><div class="line">    }</div><div class="line"></div><div class="line">    virtual void OnUnitIdle(const Unit* unit) final {</div><div class="line">        switch (unit-&gt;unit_type.ToType()) {</div><div class="line">            case UNIT_TYPEID::TERRAN_COMMANDCENTER: {</div><div class="line">                Actions()-&gt;UnitCommand(unit, ABILITY_ID::TRAIN_SCV);</div><div class="line">                break;</div><div class="line">            }</div><div class="line">            case UNIT_TYPEID::TERRAN_SCV: {</div><div class="line">                const Unit* mineral_target = FindNearestMineralPatch(unit-&gt;pos);</div><div class="line">                if (!mineral_target) {</div><div class="line">                    break;</div><div class="line">                }</div><div class="line">                Actions()-&gt;UnitCommand(unit, ABILITY_ID::SMART, mineral_target);</div><div class="line">                break;</div><div class="line">            }</div><div class="line">            default: {</div><div class="line">                break;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">private:</div><div class="line">    bool TryBuildStructure(ABILITY_ID ability_type_for_structure, UNIT_TYPEID unit_type = UNIT_TYPEID::TERRAN_SCV) {</div><div class="line">        const ObservationInterface* observation = Observation();</div><div class="line"></div><div class="line">        // If a unit already is building a supply structure of this type, do nothing.</div><div class="line">        // Also get an scv to build the structure.</div><div class="line">        const Unit* unit_to_build = nullptr;</div><div class="line">        Units units = observation-&gt;GetUnits(Unit::Alliance::Self);</div><div class="line">        for (const auto&amp; unit : units) {</div><div class="line">            for (const auto&amp; order : unit-&gt;orders) {</div><div class="line">                if (order.ability_id == ability_type_for_structure) {</div><div class="line">                    return false;</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">            if (unit-&gt;unit_type == unit_type) {</div><div class="line">                unit_to_build = unit;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        float rx = GetRandomScalar();</div><div class="line">        float ry = GetRandomScalar();</div><div class="line"></div><div class="line">        Actions()-&gt;UnitCommand(unit_to_build,</div><div class="line">            ability_type_for_structure,</div><div class="line">            Point2D(unit_to_build-&gt;pos.x + rx * 15.0f, unit_to_build-&gt;pos.y + ry * 15.0f));</div><div class="line"></div><div class="line">        return true;</div><div class="line">    }</div><div class="line"></div><div class="line">    bool TryBuildSupplyDepot() {</div><div class="line">        const ObservationInterface* observation = Observation();</div><div class="line"></div><div class="line">        // If we are not supply capped, don&#39;t build a supply depot.</div><div class="line">        if (observation-&gt;GetFoodUsed() &lt;= observation-&gt;GetFoodCap() - 2)</div><div class="line">            return false;</div><div class="line"></div><div class="line">        // Try and build a depot. Find a random SCV and give it the order.</div><div class="line">        return TryBuildStructure(ABILITY_ID::BUILD_SUPPLYDEPOT);</div><div class="line">    }</div><div class="line"></div><div class="line">    const Unit* FindNearestMineralPatch(const Point2D&amp; start) {</div><div class="line">        Units units = Observation()-&gt;GetUnits(Unit::Alliance::Neutral);</div><div class="line">        float distance = std::numeric_limits&lt;float&gt;::max();</div><div class="line">        const Unit* target = nullptr;</div><div class="line">        for (const auto&amp; u : units) {</div><div class="line">            if (u-&gt;unit_type == UNIT_TYPEID::NEUTRAL_MINERALFIELD) {</div><div class="line">                float d = DistanceSquared2D(u-&gt;pos, start);</div><div class="line">                if (d &lt; distance) {</div><div class="line">                    distance = d;</div><div class="line">                    target = u;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        return target;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">int main(int argc, char* argv[]) {</div><div class="line">    Coordinator coordinator;</div><div class="line">    coordinator.LoadSettings(argc, argv);</div><div class="line"></div><div class="line">    Bot bot;</div><div class="line">    coordinator.SetParticipants({</div><div class="line">        CreateParticipant(Race::Terran, &amp;bot),</div><div class="line">        CreateComputer(Race::Zerg)</div><div class="line">    });</div><div class="line"></div><div class="line">    coordinator.LaunchStarcraft();</div><div class="line">    coordinator.StartGame(sc2::kMapBelShirVestigeLE);</div><div class="line"></div><div class="line">    while (coordinator.Update()) {</div><div class="line">    }</div><div class="line"></div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
