\hypertarget{classsc2_1_1_connection}{}\section{sc2\+:\+:Connection Class Reference}
\label{classsc2_1_1_connection}\index{sc2\+::\+Connection@{sc2\+::\+Connection}}


{\ttfamily \#include $<$sc2\+\_\+connection.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsc2_1_1_connection_ae2b9a0a28789ac5c6304506cf0bea4b0}{Connect} (const std\+::string \&address, int port, bool verbose=true)
\item 
void \hyperlink{classsc2_1_1_connection_af6bd305434d9efd78a6868749e764749}{Send} (const S\+C2\+A\+P\+I\+Protocol\+::\+Request $\ast$request)
\item 
bool \hyperlink{classsc2_1_1_connection_a383d7968897ccc2e35c2716bb110584f}{Receive} (S\+C2\+A\+P\+I\+Protocol\+::\+Response $\ast$\&response, unsigned int timeout\+\_\+ms)
\item 
void \hyperlink{classsc2_1_1_connection_af2d5cf1aff2fef4d30ddd9ab256419ed}{Pop\+Response} (S\+C2\+A\+P\+I\+Protocol\+::\+Response $\ast$\&response)
\item 
void \hyperlink{classsc2_1_1_connection_a1a3d3c532703e0bf7a88f49ee22aa65e}{Set\+Timeout\+Callback} (std\+::function$<$ void()$>$ callback)
\item 
\mbox{\Hypertarget{classsc2_1_1_connection_a1f2556582badc5f98b349efa17d823cd}\label{classsc2_1_1_connection_a1f2556582badc5f98b349efa17d823cd}} 
void {\bfseries Set\+Connection\+Closed\+Callback} (std\+::function$<$ void()$>$ callback)
\item 
bool \hyperlink{classsc2_1_1_connection_a69ca71e72ab2a0a1bad36fc729fedc02}{Has\+Connection} () const
\item 
\mbox{\Hypertarget{classsc2_1_1_connection_a0a84c7b58a8ecb0046f6ad235ce01067}\label{classsc2_1_1_connection_a0a84c7b58a8ecb0046f6ad235ce01067}} 
void \hyperlink{classsc2_1_1_connection_a0a84c7b58a8ecb0046f6ad235ce01067}{Disconnect} ()
\begin{DoxyCompactList}\small\item\em Disconnect from the game if currently connected. \end{DoxyCompactList}\item 
bool \hyperlink{classsc2_1_1_connection_a7c06854ac5724952f69fb229a3defcee}{Poll\+Response} ()
\item 
void \hyperlink{classsc2_1_1_connection_aad919078849b1b85b38db8d8d11c8004}{Push\+Response} (S\+C2\+A\+P\+I\+Protocol\+::\+Response $\ast$\&response)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classsc2_1_1_connection_abab9f14cde0fe589fc3a1c9588c6607a}\label{classsc2_1_1_connection_abab9f14cde0fe589fc3a1c9588c6607a}} 
std\+::function$<$ void()$>$ \hyperlink{classsc2_1_1_connection_abab9f14cde0fe589fc3a1c9588c6607a}{timeout\+\_\+callback\+\_\+}
\begin{DoxyCompactList}\small\item\em Timeout callback. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classsc2_1_1_connection_a4df89365bfaec33df14cf9a84f42c938}\label{classsc2_1_1_connection_a4df89365bfaec33df14cf9a84f42c938}} 
std\+::function$<$ void()$>$ \hyperlink{classsc2_1_1_connection_a4df89365bfaec33df14cf9a84f42c938}{connection\+\_\+closed\+\_\+callback\+\_\+}
\begin{DoxyCompactList}\small\item\em Timeout callback. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
This class acts as a wrapper around a websocket connection and queue responsible for both sending out and receiving protobuf messages. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classsc2_1_1_connection_ae2b9a0a28789ac5c6304506cf0bea4b0}\label{classsc2_1_1_connection_ae2b9a0a28789ac5c6304506cf0bea4b0}} 
\index{sc2\+::\+Connection@{sc2\+::\+Connection}!Connect@{Connect}}
\index{Connect@{Connect}!sc2\+::\+Connection@{sc2\+::\+Connection}}
\subsubsection{\texorpdfstring{Connect()}{Connect()}}
{\footnotesize\ttfamily bool sc2\+::\+Connection\+::\+Connect (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{address,  }\item[{int}]{port,  }\item[{bool}]{verbose = {\ttfamily true} }\end{DoxyParamCaption})}

Connects via websocket on a given address/port. 
\begin{DoxyParams}{Parameters}
{\em address} & The address to connect to, will most commonly be used locally so 127.\+0.\+0.\+1. \\
\hline
{\em port} & The port to connect the, the default for s2api is 9168 unless specified otherwise in settings. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns true if the connection was successful and false otherwise. 
\end{DoxyReturn}
\mbox{\Hypertarget{classsc2_1_1_connection_a69ca71e72ab2a0a1bad36fc729fedc02}\label{classsc2_1_1_connection_a69ca71e72ab2a0a1bad36fc729fedc02}} 
\index{sc2\+::\+Connection@{sc2\+::\+Connection}!Has\+Connection@{Has\+Connection}}
\index{Has\+Connection@{Has\+Connection}!sc2\+::\+Connection@{sc2\+::\+Connection}}
\subsubsection{\texorpdfstring{Has\+Connection()}{HasConnection()}}
{\footnotesize\ttfamily bool sc2\+::\+Connection\+::\+Has\+Connection (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Whether or not the connection is valid. \begin{DoxyReturn}{Returns}
true if the connection is valid, false otherwise. 
\end{DoxyReturn}
\mbox{\Hypertarget{classsc2_1_1_connection_a7c06854ac5724952f69fb229a3defcee}\label{classsc2_1_1_connection_a7c06854ac5724952f69fb229a3defcee}} 
\index{sc2\+::\+Connection@{sc2\+::\+Connection}!Poll\+Response@{Poll\+Response}}
\index{Poll\+Response@{Poll\+Response}!sc2\+::\+Connection@{sc2\+::\+Connection}}
\subsubsection{\texorpdfstring{Poll\+Response()}{PollResponse()}}
{\footnotesize\ttfamily bool sc2\+::\+Connection\+::\+Poll\+Response (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Polls the queue in a thread safe way to check if a message has been received. \begin{DoxyReturn}{Returns}
true if there is a response in the queue, false otherwise. 
\end{DoxyReturn}
\mbox{\Hypertarget{classsc2_1_1_connection_af2d5cf1aff2fef4d30ddd9ab256419ed}\label{classsc2_1_1_connection_af2d5cf1aff2fef4d30ddd9ab256419ed}} 
\index{sc2\+::\+Connection@{sc2\+::\+Connection}!Pop\+Response@{Pop\+Response}}
\index{Pop\+Response@{Pop\+Response}!sc2\+::\+Connection@{sc2\+::\+Connection}}
\subsubsection{\texorpdfstring{Pop\+Response()}{PopResponse()}}
{\footnotesize\ttfamily void sc2\+::\+Connection\+::\+Pop\+Response (\begin{DoxyParamCaption}\item[{S\+C2\+A\+P\+I\+Protocol\+::\+Response $\ast$\&}]{response }\end{DoxyParamCaption})}

Pop\+Response is called in the Receive function when a message has been received off of the civetweb thread. Alternatively you could poll for responses with Poll\+Response and consume the message manually with this function. 
\begin{DoxyParams}{Parameters}
{\em response} & The response pointer to be filled out. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classsc2_1_1_connection_aad919078849b1b85b38db8d8d11c8004}\label{classsc2_1_1_connection_aad919078849b1b85b38db8d8d11c8004}} 
\index{sc2\+::\+Connection@{sc2\+::\+Connection}!Push\+Response@{Push\+Response}}
\index{Push\+Response@{Push\+Response}!sc2\+::\+Connection@{sc2\+::\+Connection}}
\subsubsection{\texorpdfstring{Push\+Response()}{PushResponse()}}
{\footnotesize\ttfamily void sc2\+::\+Connection\+::\+Push\+Response (\begin{DoxyParamCaption}\item[{S\+C2\+A\+P\+I\+Protocol\+::\+Response $\ast$\&}]{response }\end{DoxyParamCaption})}

Push\+Response is called by a civetweb thread when it receives a message off the socket. Pushing a response triggers a condition and enqueues a message. The condition will cause anyone currently blocking for a response (if Receive is called) to wake up and be able to consume that message. 
\begin{DoxyParams}{Parameters}
{\em response} & A pointer to the Response to queue. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classsc2_1_1_connection_a383d7968897ccc2e35c2716bb110584f}\label{classsc2_1_1_connection_a383d7968897ccc2e35c2716bb110584f}} 
\index{sc2\+::\+Connection@{sc2\+::\+Connection}!Receive@{Receive}}
\index{Receive@{Receive}!sc2\+::\+Connection@{sc2\+::\+Connection}}
\subsubsection{\texorpdfstring{Receive()}{Receive()}}
{\footnotesize\ttfamily bool sc2\+::\+Connection\+::\+Receive (\begin{DoxyParamCaption}\item[{S\+C2\+A\+P\+I\+Protocol\+::\+Response $\ast$\&}]{response,  }\item[{unsigned int}]{timeout\+\_\+ms }\end{DoxyParamCaption})}

Receive will block until a message is received from its websocket connection. If a message is not received within the timeout it will set response to null and return false, it also calls a timeout callback that can be used if a user has any timeout logic. 
\begin{DoxyParams}{Parameters}
{\em response} & The response pointer to be filled out.  The max time, in milliseconds, the function will wait to receive a message. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns true if a message is received, false otherwise. 
\end{DoxyReturn}
\mbox{\Hypertarget{classsc2_1_1_connection_af6bd305434d9efd78a6868749e764749}\label{classsc2_1_1_connection_af6bd305434d9efd78a6868749e764749}} 
\index{sc2\+::\+Connection@{sc2\+::\+Connection}!Send@{Send}}
\index{Send@{Send}!sc2\+::\+Connection@{sc2\+::\+Connection}}
\subsubsection{\texorpdfstring{Send()}{Send()}}
{\footnotesize\ttfamily void sc2\+::\+Connection\+::\+Send (\begin{DoxyParamCaption}\item[{const S\+C2\+A\+P\+I\+Protocol\+::\+Request $\ast$}]{request }\end{DoxyParamCaption})}

Sends a request via the websocket connection. This function assumes Connect has been called and returned success. It will assert in debug if that\textquotesingle{}s not the case and will early out in a build that doesn\textquotesingle{}t have asserts built in. This function also allocates a byte buffer to accommodate the request, it frees that buffer before returning. 
\begin{DoxyParams}{Parameters}
{\em request} & A pointer to the Request object. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classsc2_1_1_connection_a1a3d3c532703e0bf7a88f49ee22aa65e}\label{classsc2_1_1_connection_a1a3d3c532703e0bf7a88f49ee22aa65e}} 
\index{sc2\+::\+Connection@{sc2\+::\+Connection}!Set\+Timeout\+Callback@{Set\+Timeout\+Callback}}
\index{Set\+Timeout\+Callback@{Set\+Timeout\+Callback}!sc2\+::\+Connection@{sc2\+::\+Connection}}
\subsubsection{\texorpdfstring{Set\+Timeout\+Callback()}{SetTimeoutCallback()}}
{\footnotesize\ttfamily void sc2\+::\+Connection\+::\+Set\+Timeout\+Callback (\begin{DoxyParamCaption}\item[{std\+::function$<$ void()$>$}]{callback }\end{DoxyParamCaption})}

An accessor function that a user can bind a timeout function to. 
\begin{DoxyParams}{Parameters}
{\em callback} & A functor or lambda that represents the callback. \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/sc2api/\hyperlink{sc2__connection_8h}{sc2\+\_\+connection.\+h}\end{DoxyCompactItemize}
